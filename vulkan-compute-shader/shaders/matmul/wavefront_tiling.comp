#version 460
#extension GL_EXT_control_flow_attributes : enable
#extension GL_KHR_shader_subgroup_basic: enable

const uint M = 4096;
const uint N = 4096;
const uint K = 4096;
const uint BM = 128;
const uint BN = 128;
const uint BK = 32;
const uint WM = 64;
const uint WN = 64;
const uint WNITER = 4;
const uint TM = 8; // Must be powers of 2
const uint TN = 4; // TN must be 4 for manual vectorization with vec4
const uint WAVEFRONT_SIZE = 32; // TODO: Get this from outside and then do push constant?
const uint WMITER = (WM * WN) / (WAVEFRONT_SIZE * TM * TN * WNITER);

const uint VN = N / 4; // number of vec4 in N
const uint VBN = BN / 4; // number of vec4 in BN
const uint VK = K / 4; // number of vec4 in K
const uint VBK = BK / 4; // number of vec4 in BK

const float alpha = 1.0;
const float beta = 1.0;

layout(local_size_x = BM/TM, local_size_y = BN/TN, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer readonly MatrixA {
    vec4 a_global[];
};

layout(set = 0, binding = 1) buffer readonly MatrixB {
    vec4 b_global[];
};

layout(set = 0, binding = 2) buffer MatrixC {
    vec4 c_global[]; // use vec4 for manual vectorization
};

shared float a_block[BM * BK];
shared float b_block[BK * BN];

void main() {
    uint thread_index = gl_LocalInvocationIndex;
    uint thread_num = (BN / TN) * (BM / TM);

    uint c_row = gl_WorkGroupID.y;
    uint c_col = gl_WorkGroupID.x;

    uint wavefront_size = gl_SubgroupSize;
    uint wavefront_id = gl_SubgroupID;
    uint wavefront_col = wavefront_id % (BN / WN);
    uint wavefront_row = wavefront_id / (BN / WN);

    uint wavefront_tile_m = WM / WMITER;
    uint wavefront_tile_n = WN / WNITER;

    uint thread_index_in_wavefront = thread_index % wavefront_size;
    uint thread_col_in_wavefront = thread_index_in_wavefront % (wavefront_tile_n / TN);
    uint thread_row_in_wavefront = thread_index_in_wavefront / (wavefront_tile_n / TN);
    
    uint a_global_offset = c_row * BM * K;
    uint b_global_offset = c_col * BN;
    uint c_global_offset = (c_row * BM + wavefront_row * WM) * N + c_col * BN + wavefront_col * WN;

    uint a_block_row = thread_index / VBK;
    uint a_block_col = thread_index % VBK;
    uint a_block_stride = thread_num / VBK;

    uint b_block_row = thread_index / VBN;
    uint b_block_col = thread_index % VBN;
    uint b_block_stride = thread_num / VBN;

    // Below are copied from ported::sgemmWarptiling
    // TODO: Modify
    float thread_results[WMITER * TM * WNITER * TN];
    for (uint i = 0; i < WMITER * TM * WNITER * TN; i++) {
        thread_results[i] = 0.0;
    }

    float reg_m[WMITER * TM];
    for (uint i = 0; i < WMITER * TM; i++) {
        reg_m[i] = 0.0;
    }

    float reg_n[WNITER * TN];
    for (uint i = 0; i < WNITER * TN; i++) {
        reg_n[i] = 0.0;
    }

    for (uint gk = 0; gk < K; gk += BK) {
        // Load block
        // Load from global memory to shared memory
        for (uint i = 0; i < BM; i += a_block_stride) {
            vec4 tmp = a_global[a_global_offset + (a_block_row + i) * K + a_block_col * 4];
            a_block[(a_block_col * 4 + 0) * BM + a_block_row + i] = tmp.x;
            a_block[(a_block_col * 4 + 1) * BM + a_block_row + i] = tmp.y;
            a_block[(a_block_col * 4 + 2) * BM + a_block_row + i] = tmp.z;
            a_block[(a_block_col * 4 + 3) * BM + a_block_row + i] = tmp.w;
        }
        for (uint i = 0; i < BK; i += b_block_stride) {
            vec4 tmp = b_global[b_global_offset + (b_block_row + i) * N + b_block_col * 4];
            b_block[(b_block_row + i) * BN + b_block_col * 4 + 0] = tmp.x;
            b_block[(b_block_row + i) * BN + b_block_col * 4 + 1] = tmp.y;
            b_block[(b_block_row + i) * BN + b_block_col * 4 + 2] = tmp.z;
            b_block[(b_block_row + i) * BN + b_block_col * 4 + 3] = tmp.w;
        }

        barrier();

        // Compute
        for (uint bk = 0; bk < BK; bk++) {
            // populate registers for whole warptile
            for (uint wm = 0; wm < WMITER; wm++) {
                for (uint i = 0; i < TM; i++) {
                    reg_m[wm * TM + i] = a_block[(bk * BM) + wavefront_row * WM 
                                            + wm * wavefront_tile_m + thread_row_in_wavefront * TM + i];
                }
            }
            for (uint wn = 0; wn < WNITER; wn++) {
                for (uint i = 0; i < TN; i++) {
                    reg_n[wn * TN + i] = b_block[(bk * BN) + wavefront_col * WN 
                                            + wn * wavefront_tile_n + thread_col_in_wavefront * TN + i];
                }
            }

            for (uint wm = 0; wm < WMITER; wm++) {
                for (uint wn = 0; wn < WNITER; wn++) {
                    for (uint i = 0; i < TM; i++) {
                        for (uint j = 0; j < TN; j++) {
                            thread_results[(wm * TM + i) * WNITER * TN + wn * TN + j] += 
                                reg_m[wm * TM + i] * reg_n[wn * TN + j];
                        }
                    }
                }
            }
        }

        // Increment global offset
        a_global_offset += BK;
        b_global_offset += BK * N;

        barrier();
    }

    // Write back the results
    for (uint wm = 0; wm < WMITER; wm++) {
        for (uint wn = 0; wn < WNITER; wn++) {
            uint c_wavefront_offset = c_global_offset + (wm * wavefront_tile_m) * N + wn * wavefront_tile_n;
            for (uint i = 0; i < TM; i++) {
                for (uint j = 0; j < TN; j++) {
                    // ignore multiplying alpha and beta for now
                    uint c_frag_offset = (wm * TM + i) * N + thread_col_in_wavefront * TN + j;
                    vec4 tmp = vec4(
                        thread_results[c_frag_offset + 0],
                        thread_results[c_frag_offset + 1],
                        thread_results[c_frag_offset + 2],
                        thread_results[c_frag_offset + 3]
                    );
                    c_global[c_wavefront_offset 
                        + (thread_row_in_wavefront * TM + i) * N 
                        + thread_col_in_wavefront * TN + j] = tmp;
                }
            }
        }
    }
}